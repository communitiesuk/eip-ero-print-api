package uk.gov.dluhc.printapi.testsupport.assertj.assertions

import org.assertj.core.api.AbstractObjectAssert
import org.assertj.core.api.Assertions
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.util.CheckReturnValue
import uk.gov.dluhc.printapi.database.entity.Address
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.Objects
import java.util.UUID
import javax.annotation.Generated

/**
 * [Address] specific assertions - Generated by CustomAssertionGenerator.
 */
@Generated(value = ["assertj-assertions-generator"])
class AddressAssert
/**
 * Creates a new `[AddressAssert]` to make assertions on actual Address.
 * @param actual the Address we want to make assertions on.
 */
(actual: Address?) :
    AbstractObjectAssert<AddressAssert?, Address?>(
        actual,
        AddressAssert::class.java
    ) {
    /**
     * Verifies that the actual Address's area is equal to the given one.
     * @param area the given area to compare the actual Address's area to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's area is not equal to the given one.
     */
    fun hasArea(area: String?): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting area of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>"

        // null safe check
        val actualArea = actual!!.area
        if (!Objects.deepEquals(actualArea, area)) {
            failWithMessage(assertjErrorMessage, actual, area, actualArea)
        }

        // return the current assertion for method chaining
        return this
    }

    /**
     * Verifies that the actual Address's createdBy is not null.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's createdBy is null.
     */
    fun hasCreatedBy(): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting createdBy of:\n  <%s>\nto be non-null"

        assertThat(actual!!.createdBy)
            .overridingErrorMessage(assertjErrorMessage, actual)
            .isNotNull

        // return the current assertion for method chaining
        return this
    }

    /**
     * Verifies that the actual Address's createdBy is equal to the given one.
     * @param createdBy the given createdBy to compare the actual Address's createdBy to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's createdBy is not equal to the given one.
     */
    fun hasCreatedBy(createdBy: String?): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting createdBy of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>"

        // null safe check
        val actualCreatedBy = actual!!.createdBy
        if (!Objects.deepEquals(actualCreatedBy, createdBy)) {
            failWithMessage(assertjErrorMessage, actual, createdBy, actualCreatedBy)
        }

        // return the current assertion for method chaining
        return this
    }

    /**
     * Verifies that the actual Address's dateCreated is not null.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's dateCreated is null.
     */
    fun hasDateCreated(): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting dateCreated of:\n  <%s>\nto be non-null"

        assertThat(actual!!.dateCreated)
            .overridingErrorMessage(assertjErrorMessage, actual)
            .isNotNull

        // return the current assertion for method chaining
        return this
    }

    /**
     * Verifies that the actual Address's dateCreated is equal within margin seconds to the given one.
     * @param dateCreated the given dateCreated to compare the actual Address's dateCreated to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's dateCreated is not equal to the given one.
     */
    fun hasDateCreated(dateCreated: Instant?, margin: Long = 5): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        val assertjErrorMessage =
            "\nExpecting dateCreated of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>"

        val actualDateCreated = actual!!.dateCreated
        assertThat(actualDateCreated)
            .overridingErrorMessage(
                assertjErrorMessage,
                actual,
                actualDateCreated,
                dateCreated
            )
            .isCloseTo(dateCreated, Assertions.within(margin, ChronoUnit.SECONDS))

        return this
    }

    /**
     * Verifies that the actual Address's id is not null.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's id is null.
     */
    fun hasId(): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting id of:\n  <%s>\nto be non-null"

        assertThat(actual!!.id)
            .overridingErrorMessage(assertjErrorMessage, actual)
            .isNotNull

        // return the current assertion for method chaining
        return this
    }

    /**
     * Verifies that the actual Address's id is equal to the given one.
     * @param id the given id to compare the actual Address's id to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's id is not equal to the given one.
     */
    fun hasId(id: UUID?): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting id of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>"

        // null safe check
        val actualId = actual!!.id
        if (!Objects.deepEquals(actualId, id)) {
            failWithMessage(assertjErrorMessage, actual, id, actualId)
        }

        // return the current assertion for method chaining
        return this
    }

    /**
     * Verifies that the actual Address's locality is equal to the given one.
     * @param locality the given locality to compare the actual Address's locality to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's locality is not equal to the given one.
     */
    fun hasLocality(locality: String?): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting locality of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>"

        // null safe check
        val actualLocality = actual!!.locality
        if (!Objects.deepEquals(actualLocality, locality)) {
            failWithMessage(assertjErrorMessage, actual, locality, actualLocality)
        }

        // return the current assertion for method chaining
        return this
    }

    /**
     * Verifies that the actual Address's postcode is equal to the given one.
     * @param postcode the given postcode to compare the actual Address's postcode to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's postcode is not equal to the given one.
     */
    fun hasPostcode(postcode: String?): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting postcode of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>"

        // null safe check
        val actualPostcode = actual!!.postcode
        if (!Objects.deepEquals(actualPostcode, postcode)) {
            failWithMessage(assertjErrorMessage, actual, postcode, actualPostcode)
        }

        // return the current assertion for method chaining
        return this
    }

    /**
     * Verifies that the actual Address's property is equal to the given one.
     * @param property the given property to compare the actual Address's property to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's property is not equal to the given one.
     */
    fun hasProperty(property: String?): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting property of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>"

        // null safe check
        val actualProperty = actual!!.property
        if (!Objects.deepEquals(actualProperty, property)) {
            failWithMessage(assertjErrorMessage, actual, property, actualProperty)
        }

        // return the current assertion for method chaining
        return this
    }

    /**
     * Verifies that the actual Address's street is equal to the given one.
     * @param street the given street to compare the actual Address's street to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's street is not equal to the given one.
     */
    fun hasStreet(street: String?): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting street of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>"

        // null safe check
        val actualStreet = actual!!.street
        if (!Objects.deepEquals(actualStreet, street)) {
            failWithMessage(assertjErrorMessage, actual, street, actualStreet)
        }

        // return the current assertion for method chaining
        return this
    }

    /**
     * Verifies that the actual Address's town is equal to the given one.
     * @param town the given town to compare the actual Address's town to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's town is not equal to the given one.
     */
    fun hasTown(town: String?): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting town of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>"

        // null safe check
        val actualTown = actual!!.town
        if (!Objects.deepEquals(actualTown, town)) {
            failWithMessage(assertjErrorMessage, actual, town, actualTown)
        }

        // return the current assertion for method chaining
        return this
    }

    /**
     * Verifies that the actual Address's uprn is equal to the given one.
     * @param uprn the given uprn to compare the actual Address's uprn to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's uprn is not equal to the given one.
     */
    fun hasUprn(uprn: String?): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting uprn of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>"

        // null safe check
        val actualUprn = actual!!.uprn
        if (!Objects.deepEquals(actualUprn, uprn)) {
            failWithMessage(assertjErrorMessage, actual, uprn, actualUprn)
        }

        // return the current assertion for method chaining
        return this
    }

    /**
     * Verifies that the actual Address's version is not null.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's version is null.
     */
    fun hasVersion(): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting version of:\n  <%s>\nto be non-null"

        assertThat(actual!!.version)
            .overridingErrorMessage(assertjErrorMessage, actual)
            .isNotNull

        // return the current assertion for method chaining
        return this
    }

    /**
     * Verifies that the actual Address's version is equal to the given one.
     * @param version the given version to compare the actual Address's version to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Address's version is not equal to the given one.
     */
    fun hasVersion(version: Long?): AddressAssert {
        // check that actual Address we want to make assertions on is not null.
        isNotNull

        // overrides the default error message with a more explicit one
        val assertjErrorMessage = "\nExpecting version of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>"

        // null safe check
        val actualVersion = actual!!.version
        if (!Objects.deepEquals(actualVersion, version)) {
            failWithMessage(assertjErrorMessage, actual, version, actualVersion)
        }

        // return the current assertion for method chaining
        return this
    }

    companion object {
        /**
         * An entry point for AddressAssert to follow AssertJ standard `assertThat()` statements.<br></br>
         * With a static import, one can write directly: `assertThat(myAddress)` and get specific assertion with code completion.
         * @param actual the Address we want to make assertions on.
         * @return a new `[AddressAssert]`
         */
        @CheckReturnValue
        fun assertThat(actual: Address?): AddressAssert {
            return AddressAssert(actual)
        }
    }
}
